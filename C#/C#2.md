# C#

1. 解决方案 -- f6 运行，可以检查代码是否有语法错误
2. 项目运行 f5 （调试），不调试ctrl + f5

解决方案下项目的卸载和加载 

## 二、注释的使用

解释

注销

1）单行注释 //

2）多行注释 /* */

3）文档注释 /// 多用来解释类或方法

## 三、VS 中的常用快捷键

1）Ctrl + K + D 快速对其代码

2）Ctrl + J 快速弹出智能提示

3）Ctrl + K + C 注释所选代码

4）Ctrl + K + U 取消对所选代码的注释

5）F1 转到帮助文档

6）折叠冗余代码 #Region 和 #EngRegion

## 四、变量

int num; 声明

num = 4; 赋值，将值放入声明空间

金钱类型 decimal  后面 + m

decimal d = 23.33m

先声明再赋值再使用

### 波浪线

​	红色波浪线 ：有语法错误

​	绿色波浪线：没有错误，可能会出现错误

### 命名规则

Camel：除第一个单词外，首字母大小，totalNum

Pascal：首字母都大小 MainName

### 占位符

Console.WriteLine("Hello {1}, are you want {2}", n1, n2);

多填后面参数，没效果，少填了，出现异常

异常: 没有语法错误，运行期间由于某些原因出现问题，导致程序不能正常运行。

### 接收输入

string str = Console.ReadLine();

### 转义符

\ + 特殊字符

### 字符串格式化

Console.WriteLine("{0, 0.00000}", 33);

类似 “{0, F2}”, 33 => 33.00

## 类型转换

自动类型转换, 小转大

int i = 4;

double d = i;

显示转换（强制转换），不声明会直接报错，声明丢弃多余位数据

double d = 3.3;

int i = (int) d;

字符串转换位其他类型

(1) int i = Convert.ToInt32(str);

double d = Convert.ToDouble(str);

...



(2) int number = int.Parse("123");

(3) bool b = int.TryParse("123", out number);

### Switch

switch ()

{

​	case case1: 执行代码;

​	break;

}

# Out 参数

```
public void AddByOut(out int a, int b, int c)
{
         //a = a + b + c;
         // a 未被赋值，不能直接使用，即使是调用的地方 out对应的参数初始化也没用
         a = b + c;
     }
```

# Ref 参数

能够将一个变量带入一个方法中进行改变，改变完成后，再讲改变后的值带出方法。

ref参数要求在方法外必须为其赋值，而方法内可以不赋值。

public void AddByRef(ref int a, int b, int c)
    {
        a = a + b + c; // 可以直接使用a
    }

# Params 可变参数

将实参列表中跟可变参数数组类型一致的元素都当做数组的元素去处理。

params 可变参数必须是形参列表中的最后一个元素

```csharp
public static int GetSum(params int[] n){...}

static void Main(string[] args){
    int sum = GetSum(8,9);
}
```

# 方法的重载

概念：方法的重载指的是方法名称相同，但参数不同。

参数不同，分为两种情况

1）如果参数的个数相同，那么参数的类型就不能相同。

2）如果参数的类型相同，那么参数的个数就不能相同。

# 方法的递归

方法自己调用自己

找出一个文件夹中所有的文件。

控制台打印彩色

```c
Console.BackgroundColor = ConsoleColor.White;//设置背景色
  Console.ForegroundColor = ConsoleColor.Black;//设置字体颜色
```

# ArraryList

每次集合中实际包含的元素个数（count）超过了可以包含的元素的个数（capcity）的时候，集合就会向内存中申请多开辟一倍的空间，来保证集合的长度一直够用。

.Add();	// 添加单个元素

.AddRange(new int[]{1, 2, 3});	// 添加集合元素

.AddRange(list);	

.Clear();	// 清空所有元素

.Remove(true);	// 删除单个元素，写谁删谁

.RemoveAt(0);	// 根据下标删除元素

.RemoveRange(0, 3);	// 根据下标移除一定范围的元素

.Sort();	// 升序排列

.Reverse();	// 反转

.Insert(1, "xxx");	// 向下标位置插入元素

.InsertRange(0, new string[]{ "xx", "yy" });

.Contains(1);	// 判断是否包含某个指定的元素

# Hashtable 键值对集合

在键值对集合当中，我们是根据键去找值的。

键值对对象[键]=值；

键必须唯一，值可以重复

# Path类

Path.GetFileName(filePathStr);	// 获取文件名

Path.GetFileNameWithoutExtension(filePathStr);	// 获取文件名但不包含扩展名

Path.GetExtension(filePahtStr);	// 获取文件扩展名

Paht.GetDirectoryName(filePahtStr);	// 获取文件所在的文件夹的名称

Path.GetFullPath(filePathStr);	// 获取文件所在的全路径

Path.Combine(@"c:\a\\", "b.txt");	// 连接两个字符串作为路径

# File类

具体见IO.txt 笔记

File.Create(@"C:\Users\new.txt");	// 创建一个文件

File.Delete("");	// 删除一个文件

File.Copy(path1, path2);	// 复制文件

```c#
byte[] buffer = File.ReadAllBytes(@"xx.txt");
// 将字节数组中的每一个元素都要按照我们指定的编码格式解码成字符串
string s = Encoding.Default.GetString(buffer);
// Console.WriteLine(s);
// Console.ReadKey();

// 没有这个文件的话，会给你创建一个 有的话 会给你覆盖掉
string str = "xxx";
// 需要将字符串转换成字节数组
byte[] buffer = Encoding.Default.GetBytes(str);
File.WriteAllBytes(@"xx.txt", buffer);
// Console.WriteLine("写入成功");
// Console.ReadKey();

string[] contents = File.ReadAllLines(@"xx.txt", Encoding.Default);
foreach(string item in contents){
	Console.WriteLine(item);
}
Console.ReadKey();

string str = File.ReadAllText("xx.txt", Encoding.Default);
Console.WriteLine(str);
Console.ReadKey();

File.WriteAllLines(@"xx.txt", new string[]{"aoe", "ewu"});

File.WriteAllText(@"xx.txt", "xx");

File.AppendAllText(@"xx.txt", "content");
```

# 装箱、拆箱

装箱：就是将值类型转换为引用类型。

拆箱：将引用类型转换为值类型。

# FileStream 文件流

```C#
FileStream fsRead = new FileStream(@"xx.txt", FileMode.OpenOrCreate, FileAccess.Read);

byte[] buffer = new byte[1024 * 1024 * 5];
// 3.8M 5M
// 返回本次实际读取到的有效字节数
int r = fsRead.Read(buffer, 0, buffer.Length);
// 将字节数组中每一个元素按照指定的编码格式解码成字符串
string s = Encoding.Default.GetString(buffer);
// 关闭流
fsRead.Close();
// 释放流所占用的资源
fsRead.Dispose();
```

将创建文件流对象的过程写在using 当中，会自动的帮助我们释放流所占用的资源。

```c#
using (FileStream fsWrite = new FileStream(@"xx.txt", FileMode.OpenOrCreate,FileAccess.Write)){
    string str = "xx";
    byte[] buffer = Encoding.Default.GetBytes(str);
    fsWrite.Write(buffer, 0, buffer.Length);
}
```



